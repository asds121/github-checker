# 系统设计文档

## 1. 文档概述

本文档是 GitHub Network Status Checker 项目的系统设计文档，旨在从架构层面说明系统的整体设计思路、模块划分、接口定义和数据流向。系统设计基于需求分析文档，遵循极简设计原则，确保工具简单可靠、易于维护和扩展。

## 2. 系统架构设计

### 2.1 整体架构 ⚠️ **部分内容与实际代码不符**

> **注意**：以下架构描述为原始设计文档，实际代码实现更为简化。

系统采用经典的单层架构设计，所有功能集中在一个 Python 脚本中，不涉及复杂的分布式架构或微服务设计。这种设计决策基于以下考量：首先，工具功能单一明确，不需要复杂的模块划分；其次，极简设计要求代码结构简洁，避免不必要的复杂度；最后，单层架构便于分发和运行，用户只需一个 Python 文件即可使用。

系统架构图如下所示，展示了各个组件之间的交互关系：

```
┌─────────────────────────────────────────────────────┐
│                   github_checker.py                  │
│  ┌───────────────────────────────────────────────┐  │
│  │                   Main Function               │  │
│  │  - Output Formatting                          │  │
│  └───────────────────────────────────────────────┘  │
│                          │                           │
│                          ▼                           │
│  ┌───────────────────────────────────────────────┐  │
│  │                    Checker                    │  │
│  │  - check()         : Main detection entry     │  │
│  │  - test()          : Full mode detection      │  │
│  │  - _judge()        : Result judgment          │  │
│  │  - _msg()          : Message generation       │  │
│  └───────────────────────────────────────────────┘  │
│                          │                           │
│                          ▼                           │
│  ┌───────────────────────────────────────────────┐  │
│  │                   Requests                    │  │
│  │           (External HTTP Library)             │  │
│  └───────────────────────────────────────────────┘  │
│                          │                           │
│                          ▼                           │
│  ┌───────────────────────────────────────────────┐  │
│  │              GitHub Services                  │  │
│  │  - github.com (Homepage)                      │  │
│  │  - api.github.com (API)                       │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

从架构图中可以看出，系统分为四个主要层次：用户交互层（Main Function）、业务逻辑层（Checker）、基础设施层（Requests）和外部服务层（GitHub Services）。用户交互层负责接收命令行参数、选择检测模式并格式化输出结果；业务逻辑层实现核心的检测逻辑和状态判断；基础设施层通过 requests 库发起 HTTP 请求；外部服务层代表需要检测的两个 GitHub 服务端点。

**实际代码说明：**

- 实际代码中没有命令行参数解析模块，直接使用 sys.argv 判断模式
- test() 方法在实际代码中未实现，只有 check() 方法
- 输出格式化在 main 函数中直接完成，没有独立的输出模块

### 2.2 设计原则

本系统的设计遵循以下核心原则，这些原则指导了架构决策和代码实现：

**第一原则：极简至上**。系统的每一个设计决策都以简洁为优先考虑。功能上只保留必要的核心功能，不添加华而不实的特性；代码结构上追求扁平化，避免过度封装和继承；用户体验上减少命令行参数，降低学习成本。这种极简主义设计确保工具始终保持轻量级和易用性。

**第二原则：实用主义**。设计不追求技术上的优雅或学术上的完美，而是注重实际使用效果。例如，状态判断采用简单的规则而非复杂的机器学习算法；错误处理采用防御性编程而非异常驱动的复杂流程控制；代码组织采用顺序执行而非复杂的控制流模式。

**第三原则：用户友好**。系统输出经过精心设计，确保普通用户能够快速理解检测结果。状态信息使用明确的图标和颜色（尽管命令行受限，但通过大写字母和方括号增强可读性）；建议信息给出具体的操作指导而非模糊的技术描述。

**第四原则：容错优先**。系统设计充分考虑各种异常情况，确保在网络不稳定、用户中断、超时等各种场景下都能给出合理的反馈。超时控制确保单个失败的检测不会无限等待；KeyboardInterrupt 处理确保用户可以随时退出；异常捕获确保错误信息友好而非崩溃。

## 3. 模块设计 ⚠️ **与实际代码有差异**

> **注意**：以下模块设计为原始设计文档，实际代码实现更为简化。实际代码只有 Checker 类和 main 函数，没有独立的模块划分。

### 3.1 主函数模块（Main Function）⚠️ **部分实现**

主函数模块是系统的入口点，负责协调整个检测流程。该模块的设计遵循简单的顺序执行模式：打印启动信息、执行检测、格式化输出结果、返回退出码。虽然简单，但主函数模块承担了重要的职责，包括流程控制和结果展示。

主函数模块的核心职责可以细分为以下几个方面：首先是输出控制，负责打印分隔线、格式化结果表格；然后是退出处理，根据检测结果返回适当的退出码（0表示成功，1表示错误或用户中断）。

从代码实现角度看，主函数模块的复杂度应当保持在较低水平。任何复杂逻辑都应该下沉到 Checker 类中实现，主函数只负责流程控制。

**实际实现说明：**

- [x] 打印启动信息
- [x] 创建 Checker 实例
- [x] 调用检测方法
- [x] 展示检测结果
- [x] 提供操作建议
- [ ] 命令行参数解析（未实现，当前版本无参数）

### 3.2 检测器模块（Checker Class）⚠️ **实际为 Checker 类**

检测器模块是系统的核心业务逻辑所在，包含所有的检测算法和状态判断逻辑。该模块被设计为一个独立的类（Checker），通过面向对象的方式组织相关的方法和数据。检测器模块的设计目标是高内聚低耦合，所有的检测相关功能都封装在类内部，对外只暴露必要的接口。

检测器模块包含以下核心方法：check() 方法是快速测试的入口，执行一次完整的检测流程，依次测试所有目标并收集结果；test() 方法是完整测试的入口，执行多次检测并统计结果；\_judge() 方法根据检测结果判断整体状态；\_msg() 方法根据状态生成用户友好的提示信息。

检测器模块还定义了目标列表（TARGETS），包含需要检测的两个 GitHub 服务端点。当前设计中，TARGETS 是一个类属性，包含主页（github.com）和 API（api.github.com）两个固定目标。这种设计便于未来扩展，如果需要增加更多的检测目标，只需修改 TARGETS 列表即可。

**实际实现说明：**

- [x] 快速检测（check 方法）
- [ ] 完整检测（test 方法 - 未实现）
- [x] 超时控制
- [x] 异常处理

### 3.3 状态判断模块 ⚠️ **实际为 Checker.\_judge 方法**

**职责：** 根据检测结果判断整体状态

**功能：**

- [x] 快速测试状态判断
- [ ] 完整测试状态判断（未实现）

**接口：**

```python
# 已实现
def _judge(self, results: list) -> str

# 未实现
def _judge_full(self, results: list) -> str
```

### 3.4 输出模块 ⚠️ **实际在 main 函数中实现**

输出模块负责将检测结果以用户友好的方式呈现。输出格式设计为简洁明了，包含：目标名称及状态图标、响应时间（毫秒）、整体状态判断和操作建议。对于完整测试模式，还会输出稳定性评估。

输出模块支持简单的状态区分，通过明确的图标和方括号增强可读性。

**实际实现说明：**

- [x] 表格化输出
- [x] 状态标识
- [x] 加载动画
- [ ] 统计信息展示（完整测试 - 未实现）

**注意：** 实际在 main 函数中直接实现，没有独立模块。

### 3.3 开发工具模块 ✅ **已实现**

开发工具模块包含自动化工作流程检查脚本 `check_dev_workflow.py`，用于在代码提交前自动检查开发工作流程的合规性。

#### 3.3.1 模块功能

该模块执行以下 6 项核心检查：

1. **代码规范检查**：运行 Flake8 检查 Python 代码是否符合 PEP 8 规范
2. **单元测试检查**：运行 `pytest` 确保所有单元测试通过
3. **文档完整性检查**：验证所有 Python 文件包含文档字符串
4. **Git 状态检查**：确保工作区干净，无未提交的更改
5. **README 更新检查**：验证 README.md 文件已更新
6. **CHANGELOG 更新检查**：验证 CHANGELOG.md 文件已更新

#### 3.3.2 使用方式

执行命令：

```bash
python check_dev_workflow.py
```

输出示例：

```
✅ 代码规范检查通过
✅ 单元测试检查通过
✅ 文档完整性检查通过
✅ Git 状态检查通过
✅ README 更新检查通过
✅ CHANGELOG 更新检查通过

所有检查项通过！可以安全提交代码。
```

如果某项检查失败，会显示详细的错误信息和建议的修复方法。

#### 3.3.3 设计特点

- **模块化检查**：每项检查独立实现，便于维护和扩展
- **友好输出**：使用 ✅/❌ 符号清晰显示检查结果
- **详细反馈**：失败时提供具体的错误位置和修复建议
- **流程集成**：设计为在代码提交前执行，确保代码质量

**实现状态：** ✅ **已实现**

## 4. 接口设计 ⚠️ **与实际代码有差异**

### 4.1 外部接口

#### 4.1.1 程序退出码 ✅ **已实现**

系统的外部接口主要包括程序退出码。程序退出码用于与其他脚本或工具集成。

程序退出码定义如下：退出码 0 表示检测成功完成（无论网络状态如何）；退出码 1 表示发生错误或用户中断。这种设计符合 Unix 传统，0 表示成功，非零表示异常。

#### 4.1.2 命令行参数接口 ❌ **未实现**

> **注意**：当前版本（v1.0）不支持任何命令行参数。程序启动后直接执行快速测试。

**原始设计（未实现）：**

| 参数        | 类型   | 必需 | 默认值  | 说明                                               |
| ----------- | ------ | ---- | ------- | -------------------------------------------------- |
| `--mode`    | string | 否   | `quick` | 测试模式：`quick`（快速测试）或 `full`（完整测试） |
| `--timeout` | int    | 否   | `8`     | 请求超时时间（秒）                                 |
| `--rounds`  | int    | 否   | `3`     | 完整测试的轮数                                     |
| `--verbose` | bool   | 否   | `False` | 显示详细输出                                       |

**实现状态：** ❌ **未实现** - 当前版本不支持命令行参数

#### 4.1.3 HTTP 接口 ✅ **已实现**

程序作为客户端，向以下目标发起 HTTP 请求：

| 目标           | 方法 | 路径 | 说明         |
| -------------- | ---- | ---- | ------------ |
| github.com     | GET  | /    | 主站首页     |
| api.github.com | GET  | /    | API 服务首页 |

**实现状态：** ✅ **已实现**

### 4.2 内部接口 ⚠️ **与实际代码有差异**

系统内部接口主要指 Checker 类对外暴露的方法接口。这些接口经过精心设计，既满足了功能需求，又保持了类的封装性。

#### 4.2.1 Checker 类主要接口

**已实现的接口：**

check(timeout: float = 8.0) -> dict 方法执行快速测试，接收超时时间参数，返回包含检测结果的字典。返回字典的结构包括：status 字段表示整体状态（good/warn/bad）；ms 字段表示总耗时（毫秒）；results 字段包含每个目标的检测结果列表；msg 字段表示状态描述文本。

**未实现的接口：**

test(timeout: float = 8.0) -> dict 方法执行完整测试，接收超时时间参数，返回包含详细统计信息的字典。该方法执行3次检测，计算整体统计信息和每个目标的平均响应时间及成功率。

**实现状态：**

- check() 方法：✅ **已实现**
- test() 方法：❌ **未实现**

#### 4.2.2 私有方法接口 ✅ **已实现**

内部方法 \_test()、\_judge() 和 \_msg() 是私有方法，仅供类内部使用，不对外暴露。这种设计遵循了面向对象的封装原则，确保类的内部实现可以自由修改而不影响外部使用。

**实现状态：** ✅ **已实现**

### 4.3 数据结构

系统使用的主要数据结构是字典（dict），用于在各模块之间传递检测结果。字典结构经过精心设计，兼顾了信息完整性和使用便利性。

#### 4.3.1 单个目标检测结果 ✅ **已实现**

```python
{
    "ok": True,        # 布尔值，表示是否成功
    "ms": 234,         # 整数，表示延迟（毫秒）
    "error": "timeout" # 字符串，仅在失败时存在，表示错误原因
}
```

#### 4.3.2 快速测试返回结果 ✅ **已实现**

```python
{
    "status": "good",  # 状态：good/warn/bad
    "ms": 500,         # 总耗时（毫秒）
    "results": [       # 检测结果列表
        ("homepage", {"ok": True, "ms": 234}),
        ("api", {"ok": True, "ms": 312})
    ],
    "msg": "[OK] GitHub is accessible" # 状态消息
}
```

#### 4.3.3 完整测试返回结果 ❌ **未实现**

> **注意**：此数据结构在当前版本中未使用。

```python
{
    "status": "good",  # 整体状态
    "msg": "[OK] GitHub is accessible (avg 234ms)",  # 状态消息
    "iterations": 3,  # 迭代次数
    "avg_total_time": 500,  # 平均总耗时(毫秒)
    "successful_checks": 3,  # 成功检测次数
    "target_stats": {  # 各目标统计信息
        "homepage": {
            "avg_response": 234,  # 平均响应时间(毫秒)
            "success_rate": 100.0  # 成功率(%)
        },
        "api": {
            "avg_response": 312,
            "success_rate": 100.0
        }
    },
    "all_results": [...]  # 所有检测结果的详细列表
}
```

**实现状态：** ❌ **未实现**

## 5. 数据流向

### 5.1 快速测试数据流向 ⚠️ **已实现**

快速测试模式的数据流向相对简单，遵循以下流程：

用户启动程序后，主函数打印启动信息并执行检测。主函数实例化 Checker 类并调用 check() 方法。check() 方法内部遍历 TARGETS 列表，对每个目标调用 \_test() 方法发起 HTTP 请求。\_test() 方法使用 requests 库发送 GET 请求，根据响应状态码和请求耗时构建结果字典。

所有目标检测完成后，check() 方法调用 \_judge() 方法进行状态判断。\_judge() 方法首先检查是否有任何成功的结果，如果没有则返回 "bad" 状态；如果部分成功则返回 "warn" 状态；如果全部成功，则计算平均延迟并与阈值比较，决定返回 "good" 还是 "warn" 状态。

状态判断完成后，check() 方法调用 \_msg() 方法生成用户友好的状态消息。最后，check() 方法将所有结果打包成字典返回给主函数。

主函数收到结果后，格式化输出各个目标的检测状态和延迟，然后输出整体状态和操作建议。整个流程清晰单向，没有复杂的分支或回溯。

### 5.2 完整测试数据流向 ❌ **未实现**

> **注意**：完整测试模式在当前版本中未实现。以下流程为原始设计。

完整测试模式的数据流向在快速测试的基础上增加了循环和统计逻辑：

主函数解析参数后,调用 test() 方法并传入超时时间参数。test() 方法执行3次检测,每次检测都调用 check() 方法获取完整检测结果。在每次检测后,收集每个目标的响应时间和成功状态,用于后续统计计算。

3次检测完成后,test() 方法计算整体统计信息,包括总耗时、整体成功率、平均响应时间等指标。同时,为每个目标计算平均响应时间和成功率。

最后,test() 方法构建包含详细统计信息的返回字典,包括整体统计信息和每个目标的统计信息。主函数收到结果后,输出这些统计信息。

**实现状态：** 当前版本（v1.0）未实现完整测试模式。

### 5.3 异常处理数据流向

系统设计了完善的异常处理机制，确保各种错误情况都能得到妥善处理：

网络异常（如连接超时、DNS 解析失败、TLS 错误等）会被 \_test() 方法捕获，作为检测失败处理，不会导致程序崩溃。用户中断（Ctrl+C）会在主函数中被 KeyboardInterrupt 异常处理器捕获，输出中断提示并返回退出码 1。其他未预期的异常由通用的异常处理器捕获，输出错误信息并返回退出码 1。

## 6. 错误处理设计

### 6.1 错误分类

系统将可能遇到的错误分为三类：网络错误、程序错误和用户错误。网络错误是指由于网络环境导致的检测失败，如连接超时、DNS 解析失败、SSL 错误、连接被拒绝等，这类错误由 \_test() 方法捕获并转化为检测失败结果。程序错误是指由于代码缺陷导致的异常，如参数错误、状态码异常等，这类错误由通用的异常处理器捕获并输出错误信息。用户错误主要指用户中断（Ctrl+C），由专门的异常处理器处理。

### 6.2 错误处理策略

针对不同类型的错误，系统采用不同的处理策略：

对于网络错误，系统采用容错策略。网络错误被当作普通的检测失败处理，不记录错误详情（避免泄露敏感信息），只记录错误类型。检测继续进行，不因单个目标失败而中断。这种策略确保了检测结果的完整性，用户可以了解每个目标的独立状态。

对于程序错误，系统采用防御策略。任何未预期的异常都会被捕获并输出友好的错误信息。错误信息包含异常类型但不包含堆栈跟踪（避免普通用户困惑）。程序返回非零退出码，表示执行失败。

对于用户中断，系统采用优雅退出策略。用户按下 Ctrl+C 时，程序立即停止检测，打印中断提示（而非错误信息），并返回退出码 1。这种设计尊重用户的中断意愿，不强制用户等待检测完成。

## 7. 扩展性设计

### 7.1 检测目标扩展

当前系统仅检测 GitHub 主页和 API 两个目标，但设计时预留了扩展能力。如需增加新的检测目标，只需修改 Checker 类的 TARGETS 属性。例如，增加 GitHub Pages 检测：

```python
TARGETS = [
    ("homepage", "https://github.com"),
    ("api", "https://api.github.com"),
    ("pages", "https://pages.github.com"),
]
```

这种设计不需要修改任何检测逻辑，新增目标会自动参与检测和状态判断。

### 7.2 功能扩展

系统采用模块化设计，便于添加新功能。如果需要添加新的检测模式（如 VIP 模式、代理模式等），只需在 Checker 类中添加新的方法，主函数的参数解析部分添加相应选项即可。如果需要持久化检测结果或生成报告，可以添加文件输出模块，与现有代码保持松耦合。

### 7.3 第三方库替换

系统当前使用 requests 库发起 HTTP 请求。如果需要减少依赖（如在资源受限环境使用），可以替换为标准库的 urllib 或 http.client。替换时只需修改 \_test() 方法中的 HTTP 客户端调用，检测逻辑和状态判断保持不变。

## 8. 性能考量

### 8.1 时间复杂度

系统的时间复杂度主要取决于网络请求时间。在快速测试模式下，时间复杂度为 O(n)，其中 n 是检测目标数量（当前为 2）。在完整测试模式下，时间复杂度为 O(n × m)，其中 m 是检测次数。由于 n 和 m 都是固定的小数值（通常 n=2，m=5），系统的时间开销是可控的。

### 8.2 空间复杂度

系统的空间复杂度为 O(n)，主要用于存储检测结果。由于检测目标数量固定且结果数据很小（每个结果仅包含几个字段），内存占用始终保持在较低水平（估计 < 1MB）。

### 8.3 性能优化策略

系统采用以下策略优化性能：请求超时控制确保单个请求不会无限等待；资源复用避免重复创建对象。这些策略确保了系统在实际使用中保持轻量和快速。

## 9. 安全考量

### 9.1 输入验证

系统对所有用户输入进行验证，包括命令行参数的类型检查和范围限制。例如，检测次数必须是正整数，超时时间必须是正数。这种防御性编程防止了恶意或错误的输入导致程序异常。

### 9.2 输出安全

系统输出经过脱敏处理，不包含任何敏感信息。错误信息只显示错误类型，不显示网络地址、请求头内容等可能被利用的信息。这种设计保护了用户的隐私和安全。

### 9.3 网络安全

系统发送的 HTTP 请求使用固定的 User-Agent 头标识自身，便于服务端识别和统计。请求不携带任何认证信息，避免了凭证泄露风险。HTTPS 确保传输加密，防止中间人攻击。

## 10. 部署设计

### 10.1 部署方式

系统采用绿色软件模式部署，无需安装，直接运行 Python 脚本即可。分发时只需提供 github_checker.py 文件和依赖说明（requirements.txt）。

### 10.2 依赖管理

系统仅依赖 requests 库，版本要求为 requests >= 2.20.0（支持 Python 3.6+）。用户可以通过 pip install -r requirements.txt 安装依赖，或直接运行 pip install requests。

### 10.3 入口文件

在 Windows 环境下，提供 start.bat 作为便捷入口，用户双击即可运行工具。start.bat 设置编码为 UTF-8，确保中文输出正确显示，然后调用 Python 执行检测脚本。

## 11. 设计变更记录

| 版本 | 日期       | 变更内容         | 变更原因                             |
| ---- | ---------- | ---------------- | ------------------------------------ |
| 1.0  | 2024-12-23 | 初始系统设计     | 项目启动                             |
| 1.1  | 2024-12-23 | 调整阈值判断逻辑 | 根据实际测试反馈，优化状态判断准确性 |
