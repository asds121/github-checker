# 详细设计文档

**文档版本**: v1.2.0
**最后更新**: 2025-01-25
**适用版本**: GitHub Checker v1.3.0+
**更新说明**: 更新文档版本信息以匹配v1.3.0，添加新模块详细说明（Checker类、反馈系统、主题模块等）

---

## 1. 文档概述

本文档是 GitHub Network Status Checker 项目的详细设计文档，旨在从代码实现层面详细说明系统的各个模块、函数、数据结构和算法。详细设计文档是编码实现的直接指导，确保开发人员能够准确地将设计意图转化为可工作的代码。本文档基于需求分析文档和系统设计文档，提供了足够详细的实现细节，包括每个函数的参数、返回值、业务逻辑和边界条件处理。

本文档的目标读者包括：开发人员（根据本文档实现代码）、维护人员（理解代码逻辑进行维护）、技术评审人员（审查设计合理性）。文档内容经过精心组织，从整体到局部，从宏观到微观，层层递进地展示系统的实现细节。

## 2. 代码整体结构

### 2.1 文件组织

项目代码组织简洁明了，所有功能集中在一个 Python 脚本文件中。这种组织方式符合极简设计原则，便于分发和运行。项目目录结构如下：

```
github-checker-检测状态/
├── cli.py              # 主程序文件，包含所有功能实现
├── start.bat           # Windows 便捷启动脚本
├── README.md           # 项目说明文档
├── LICENSE             # 开源许可证
├── .gitignore          # Git 忽略配置
└── docs/               # 文档目录
    ├── 01-需求分析.md   # 需求分析文档
    ├── 02-系统设计.md   # 系统设计文档
    └── 03-详细设计.md   # 本文档
```

cli.py 是项目的核心文件，包含所有功能实现。所有功能实现——包括命令行参数解析、检测逻辑、状态判断、结果展示等——都集中在这个文件中。这种高度集成的设计虽然牺牲了一定的模块化程度，但显著降低了代码复杂度，使工具更容易理解和维护。

### 2.2 代码结构概览

代码文件 cli.py 的结构按功能分为以下几个部分：

文件开头是文件头声明和模块级文档字符串，包含程序名称、核心功能和作者信息。文件头使用标准的 Unix shebang（#!/usr/bin/env python3）声明解释器路径，使用编码声明（# -_- coding: ascii -_-）确保源码使用 ASCII 编码，避免编码问题导致的兼容性问题。

接下来是导入语句区域，当前代码导入了三个标准库模块：sys（用于系统相关功能，如退出码）、time（用于时间测量）、requests（第三方库，用于发起 HTTP 请求）。这种最小化的依赖列表是极简设计的重要体现。

导入语句之后是主程序区域，包含类定义（Checker 类）和函数定义（spinning_cursor 生成器、main 主函数）。这种顺序安排确保了依赖关系正确——函数可以调用在它之前定义的类和函数。

### 2.3 Checker 类详细设计

Checker 类是系统的核心业务逻辑封装，提供了 GitHub 访问性检测的所有功能。该类的设计遵循面向对象原则，将相关的状态（检测目标列表）和行为（检测方法、判断方法）组织在一起，同时保持对外接口的简洁性。Checker 类的实例在每次运行时创建，使用后销毁，不维护持久状态，这种设计确保了工具的无状态性和可重复性。

类的核心设计理念是"检测即服务"——用户创建 Checker 实例，调用检测方法，获取结果。检测方法封装了所有的复杂逻辑，包括网络请求、超时控制、状态判断等，对外只暴露简洁的接口。这种封装不仅简化了主函数的实现，也便于未来的扩展和维护。

### 3.1 类概述

Checker 类是系统的核心业务逻辑封装，提供了 GitHub 访问性检测的所有功能。该类的设计遵循面向对象原则，将相关的状态（检测目标列表）和行为（检测方法、判断方法）组织在一起，同时保持对外接口的简洁性。Checker 类的实例在每次运行时创建，使用后销毁，不维护持久状态，这种设计确保了工具的无状态性和可重复性。

类的核心设计理念是"检测即服务"——用户创建 Checker 实例，调用检测方法，获取结果。检测方法封装了所有的复杂逻辑，包括网络请求、超时控制、状态判断等，对外只暴露简洁的接口。这种封装不仅简化了主函数的实现，也便于未来的扩展和维护。

### 3.2 类属性设计

#### 3.2.1 TARGETS 属性

TARGETS 是 Checker 类最重要的类属性，定义了需要检测的 GitHub 服务端点列表。属性定义为类属性而非实例属性，是因为检测目标在程序运行期间不会改变，所有实例共享同一份配置即可。这种设计节省了内存，也便于集中管理配置。

```python
TARGETS = [
    ("homepage", "https://github.com"),
    ("api", "https://api.github.com"),
]
```

TARGETS 是一个列表，每个元素是一个元组，包含两个字段：name（名称标识）和 url（完整 URL）。这种数据结构设计便于在检测时迭代使用，元组的不可变性确保了配置不会被意外修改。name 字段用于输出显示，url 字段用于发起实际的网络请求。

当前 TARGETS 包含两个检测目标：github.com（GitHub 主页）和 api.github.com（GitHub REST API）。这两个端点覆盖了用户日常使用 GitHub 的主要场景。主页检测确保网页访问正常，API 检测确保接口调用正常。两者同时成功才能确认 GitHub 完全可用。

TARGETS 的设计具有良好的可扩展性。如需增加新的检测目标（如 GitHub Pages、Raw 文件服务等），只需在列表中添加新的元组，检测逻辑会自动包含新增目标。这种"配置即扩展"的方式避免了修改检测代码，降低了引入 bug 的风险。

### 3.3 check 方法详细设计

#### 3.3.1 方法签名

```python
def check(self, timeout: float = 8.0) -> dict
```

check 方法是快速测试模式的入口方法，负责执行一次完整的检测流程。方法接收一个可选的 timeout 参数，指定单次检测的超时时间（秒），默认为 8.0 秒。方法返回包含检测结果的字典，供主函数展示和判断使用。

#### 3.3.2 参数说明

| 参数    | 类型  | 默认值 | 说明                         |
| ------- | ----- | ------ | ---------------------------- |
| timeout | float | 8.0    | 单次检测的超时时间，单位为秒 |

timeout 参数的设计考虑了两个方面：一是默认值 8 秒足够完成大多数正常请求，二是允许调用者根据网络环境调整超时时间。在网络较慢的环境下，可以适当增加超时时间；在追求快速响应的场景下，可以减少超时时间。

#### 3.3.3 返回值说明

check 方法返回一个字典，包含以下字段：

```python
{
    "status": str,      # 状态标识：good/warn/bad
    "ms": float,        # 总耗时（毫秒）
    "results": list,    # 检测结果列表
    "msg": str          # 状态描述文本
}
```

返回字典的结构经过精心设计，包含了展示结果所需的全部信息，同时保持结构简洁。status 字段是后续判断的主要依据；ms 字段记录了总耗时，可用于性能监控；results 字段包含每个目标的详细结果，便于逐项展示；msg 字段是预格式化的状态文本，可直接输出给用户。

#### 3.3.4 业务流程

check 方法的业务流程分为以下步骤：

**步骤一：初始化计时和结果列表**

方法开始时记录开始时间（start），初始化空的结果列表（results）。开始时间使用 time.time() 获取，确保精度足够测量毫秒级的时间差。

**步骤二：迭代检测目标**

方法遍历 TARGETS 列表中的每个检测目标。对于每个目标：

- 计算剩余可用时间（remain）：总超时时间减去已消耗时间
- 调用 \_test() 方法执行实际的网络检测
- 将检测结果添加到结果列表
- 如果是主页检测且检测失败，提前终止循环（优化：主页失败时 API 通常也会失败）

这种早期终止策略在检测到主页不可达时跳过 API 检测，节省了等待 API 超时的时间，使工具在网络完全断开时能够更快给出结果。

**步骤三：计算总耗时**

所有检测完成后，计算从开始到现在的总耗时，转换为毫秒。总耗时包含所有检测目标的时间之和，以及方法调用的开销（通常可忽略）。

**步骤四：状态判断**

调用 \_judge() 方法，根据检测结果判断整体状态。状态判断逻辑详见后文。

**步骤五：生成状态消息**

调用 \_msg() 方法，根据状态生成用户友好的描述文本。

**步骤六：组装返回结果**

将状态、耗时、结果列表和状态消息组装成字典返回。

#### 3.3.5 边界条件处理

check 方法处理了以下边界条件：

**无检测目标**：如果 TARGETS 为空，results 列表将为空，\_judge() 方法会正确返回 "bad" 状态。

**超时时间过短**：如果剩余时间（remain）小于1秒，会被调整为至少1秒，避免极短的超时导致请求立即失败。这确保了即使在检测开始时已经消耗了大量时间，剩余目标仍有机会完成检测。

**所有检测都失败**：\_judge() 方法会正确识别并返回 "bad" 状态。

**部分成功**：\_judge() 方法会正确识别并返回 "warn" 状态。

### 3.4 \_test 方法详细设计

#### 3.4.1 方法签名

```python
def _test(self, url: str, timeout: float) -> dict
```

\_test 方法是底层的网络检测方法，负责对单个 URL 发起 HTTP 请求并返回检测结果。方法以下划线前缀命名，表示这是私有方法，仅供类内部使用。

#### 3.4.2 参数说明

| 参数    | 类型  | 说明               |
| ------- | ----- | ------------------ |
| url     | str   | 要检测的目标 URL   |
| timeout | float | 请求超时时间（秒） |

#### 3.4.3 返回值说明

方法返回一个字典，包含检测结果：

```python
{
    "ok": bool,      # 是否成功（HTTP 状态码为 200）
    "ms": int,       # 请求耗时（毫秒）
    "error": str     # 可选，错误描述（仅在异常时存在）
}
```

#### 3.4.4 业务流程

\_test 方法的业务流程：

**步骤一：记录请求开始时间**

使用 time.time() 记录请求开始时间，用于计算请求耗时。

**步骤二：发起 HTTP 请求**

使用 requests.get() 发起 GET 请求。请求配置包括：

- URL：参数传入的目标地址
- timeout：参数传入的超时时间
- headers：包含 User-Agent 头，标识请求来源为 GitHubChecker/1.0

User-Agent 的设置是良好的网络礼仪，便于服务端识别请求来源，统计工具使用情况，同时避免被某些严格的网站拦截。

**步骤三：处理正常响应**

如果请求成功（requests 库没有抛出异常），检查响应状态码。如果状态码为 200，认为检测成功；否则认为检测失败（某些端点可能返回其他状态码，如重定向）。

**步骤四：处理异常情况**

如果请求过程中发生任何异常（如连接超时、DNS 解析失败、TLS 错误、连接被拒绝等），except 块会捕获异常并将检测标记为失败。异常信息被转换为字符串存储在 error 字段中，用于调试和问题排查。

**步骤五：计算耗时并返回**

计算请求耗时（当前时间减去开始时间），转换为毫秒。将 ok、ms 和可选的 error 字段组装成字典返回。

#### 3.4.5 异常处理细节

\_test 方法捕获所有 Exception 类型的异常，这是有意为之的宽泛捕获。网络请求可能遇到各种异常情况，包括但不限于：

**连接超时（requests.exceptions.Timeout）**：服务器在规定时间内未响应，可能是服务器繁忙或网络延迟过高。

**连接错误（requests.exceptions.ConnectionError）**：无法建立连接，可能是 DNS 解析失败、服务器不可达、网络断开等。

**SSL 错误（requests.exceptions.SSLError）**：SSL/TLS 握手失败，可能是证书问题或中间人攻击。

**其他网络错误**：requests 库可能抛出其他类型的网络异常。

通过捕获所有异常，确保任何网络问题都被当作检测失败处理，不会导致程序崩溃。异常信息被转换为字符串存储，这是安全的设计选择——它提供了足够的调试信息，同时不会暴露敏感的系统详情。

### 3.5 \_judge 方法详细设计

#### 3.5.1 方法签名

```python
def _judge(self, results: list) -> str
```

\_judge 方法负责根据检测结果判断整体状态。方法接收检测结果列表，返回状态标识字符串。

#### 3.5.2 参数说明

| 参数    | 类型 | 说明                                              |
| ------- | ---- | ------------------------------------------------- |
| results | list | 检测结果列表，每个元素为 (name, result_dict) 元组 |

#### 3.5.3 返回值说明

方法返回以下状态字符串之一：

| 返回值 | 说明                     |
| ------ | ------------------------ |
| "good" | 网络正常，可以操作       |
| "warn" | 网络不稳定，建议谨慎操作 |
| "bad"  | 网络完全不可用           |

#### 3.5.4 状态判断逻辑

\_judge 方法实现的状态判断逻辑遵循以下优先级规则：

**规则一：无结果判定为坏**

如果 results 列表为空（没有任何检测结果），直接返回 "bad" 状态。这是一种防御性处理，避免空结果导致的除零错误或后续逻辑异常。

**规则二：统计成功数量**

统计所有成功的检测数量（ok 字段为 True 的结果）。成功数量用于后续的状态判断。

**规则三：全部失败判定为坏**

如果成功数量为 0（所有检测都失败），返回 "bad" 状态，表示网络完全不可用。

**规则四：部分成功判定为警告**

如果成功数量小于检测目标总数（部分成功），返回 "warn" 状态，表示网络部分不可用。这种情况通常意味着某些服务不可达，但并非完全断开连接。

**规则五：全部成功时判断延迟**

如果所有检测都成功，计算平均延迟。如果平均延迟小于 3000 毫秒（3秒），返回 "good" 状态；否则返回 "warn" 状态。

#### 3.5.5 延迟阈值设计

平均延迟阈值 3000 毫秒的选择基于以下考量：

**用户体验角度**：3秒是用户能接受的等待时间的上限。超过3秒的页面加载会让用户感到明显卡顿，降低工作效率。

**网络环境角度**：考虑到国内访问 GitHub 的网络延迟普遍较高（受国际出口带宽影响），3000毫秒是一个相对宽松的阈值，避免误报网络不稳定。

**设计意图角度**：工具的目的是帮助用户判断是否可以进行代码操作，而不是精确测量网络性能。稍微宽松的阈值确保用户不会因为短暂的波动而频繁收到警告。

阈值可以根据实际使用反馈进行调整。系统设计时预留了这个灵活性——只需修改 \_judge 方法中的数值常量，即可调整状态判断的严格程度。

### 3.6 \_msg 方法详细设计

#### 3.6.1 方法签名

```python
def _msg(self, status: str, results: list) -> str
```

\_msg 方法根据状态生成用户友好的描述文本。方法接收状态标识和结果列表，返回格式化的状态消息。

#### 3.6.2 参数说明

| 参数    | 类型 | 说明                                 |
| ------- | ---- | ------------------------------------ |
| status  | str  | 状态标识：good/warn/bad              |
| results | list | 检测结果列表（当前未使用，预留扩展） |

results 参数在当前实现中未被使用，但保留在方法签名中是考虑到未来可能需要根据具体失败的检测目标生成更详细的消息。例如，在部分失败时，可以指出具体哪些服务不可达。

#### 3.6.3 返回值说明

方法返回预定义的状态消息：

| status | 返回消息                          |
| ------ | --------------------------------- |
| "good" | "[OK] GitHub is accessible"       |
| "warn" | "[WARN] GitHub is unstable"       |
| "bad"  | "[FAIL] Cannot connect to GitHub" |

#### 3.6.4 消息格式设计

状态消息采用方括号前缀的格式，这种设计参考了日志级别的常见约定，使用户能够快速识别消息类型。消息内容简洁明确，避免技术术语，确保普通用户能够理解。

**"[OK] GitHub is accessible"**：明确告知用户 GitHub 可以正常访问，可以进行代码操作。

**"[WARN] GitHub is unstable"**：警告用户网络不稳定，操作可能遇到问题，建议等待或使用代理。

**"[FAIL] Cannot connect to GitHub"**：明确告知用户无法连接 GitHub，建议检查网络或 VPN 设置。

消息中的大写字母（OK、WARN、FAIL）增强了视觉识别性，即使在快速扫视时也能快速识别消息类型。

## 4. 主函数详细设计

### 4.1 函数签名

```python
def main() -> int
```

main 函数是程序的入口点，被设计为可调用函数而非直接在全局作用域执行代码。这种设计使得代码更容易测试（可以在其他模块中导入并调用 main 函数），同时符合良好的 Python 编码实践。

函数返回整数作为退出码：0 表示程序正常结束，1 表示发生错误或用户中断。

### 4.2 启动流程

#### 4.2.1 打印启动信息

程序启动时，首先打印程序标题和分隔线：

```python
print("GitHub Network Status Checker v1.0")
print("=" * 40)
print("Checking GitHub accessibility...")
```

标题使用固定宽度的分隔线（40个等号）装饰，增强输出的美观性和结构性。启动信息简短明了，告诉用户程序正在运行以及正在做什么。

#### 4.2.2 初始化加载动画

启动信息打印后，初始化加载动画生成器：

```python
spinner = spinning_cursor()
```

创建生成器实例，用于在后续检测过程中产生动画效果。动画在单独的线程或异步任务中运行？不，本系统的动画实现是伪动画——通过在检测过程中不断打印下一个动画字符来实现。这种简单的实现避免了复杂的线程同步，同时提供了视觉反馈。

### 4.3 检测执行流程

#### 4.3.1 调用检测方法

主函数创建 Checker 实例并调用 check 方法：

```python
chk = Checker()
r = chk.check(timeout=8.0)
```

创建实例时不需要传入任何参数，因为所有配置都硬编码在类属性中。这是极简设计的体现——用户不需要了解任何配置选项，工具开箱即用。

#### 4.3.2 清除加载动画

检测完成后，清除加载动画：

```python
print("\r" + " " * 50 + "\r", end="")
```

这行代码首先打印回车符（移到行首），然后打印50个空格覆盖原有内容，最后再次打印回车符完成换行。这种技巧确保加载动画被完全清除，不会在结果上方留下残留字符。

### 4.4 结果展示流程

#### 4.4.1 打印结果标题

```python
print("\nResults:")
print("-" * 40)
```

使用分隔线组织输出，使结果区域清晰可见。分隔线长度为40个减号，与启动分隔线保持一致。

#### 4.4.2 逐项打印检测结果

```python
for name, result in r["results"]:
    status = "OK" if result.get("ok") else "FAIL"
    ms = result.get("ms", 0)
    print(f"  {name:10}: {status:4} ({ms:.0f}ms)")
```

结果展示采用表格形式，每个目标一行。使用格式化字符串控制对齐：

- `{name:10}`：名称字段占10字符宽度，右对齐
- `{status:4}`：状态字段占4字符宽度，右对齐
- `{ms:.0f}`：延迟取整（去掉小数部分），避免出现0.5ms这样的无意义精度

这种表格输出使结果清晰易读，用户可以快速比较各个目标的检测状态。

#### 4.4.3 打印整体状态

```python
print("-" * 40)
print(f"\nStatus: {r['msg']}")
```

在结果表格后打印整体状态，使用之前生成的状态消息。

#### 4.4.4 打印操作建议

根据检测状态打印相应的操作建议：

```python
if r["status"] == "good":
    print("\nSuggestion: You can push code normally.")
elif r["status"] == "warn":
    print("\nSuggestion: Try again later, or use proxy.")
else:
    print("\nSuggestion: Check network connection or VPN.")
```

建议信息根据状态动态选择，为用户提供明确的操作指导。消息简短直接，避免技术术语，确保普通用户能够理解并采取行动。

### 4.5 异常处理

main 函数使用多层异常处理，确保各种异常情况都能得到妥善处理：

#### 4.5.1 KeyboardInterrupt 处理

```python
except KeyboardInterrupt:
    print("\n\nInterrupted by user.")
    return 1
```

当用户按下 Ctrl+C 时，程序捕获 KeyboardInterrupt 异常，打印中断提示（而非错误信息），并返回退出码 1。这种处理方式尊重用户的中断意愿，同时给予明确的反馈。

#### 4.5.2 通用异常处理

```python
except Exception as e:
    print(f"\nError: {e}")
    return 1
```

任何未预期的异常都会被捕获，打印错误信息（仅显示异常消息，不显示堆栈跟踪，避免普通用户困惑），并返回退出码 1。这种防御性处理确保程序不会在异常情况下崩溃或给出难以理解的信息。

#### 4.5.3 正常结束

```python
return 0
```

如果程序正常执行到最后（没有异常、没有中断），返回退出码 0，表示程序成功完成。

### 4.6 程序入口

```python
if __name__ == "__main__":
    sys.exit(main())
```

程序入口采用标准的 Python 模式：检查 **name** 变量确保代码只在直接运行时执行，而不是被导入时执行。使用 sys.exit() 调用 main 函数，确保程序的退出码能够正确传递给操作系统。

## 5. 动画模块详细设计

### 5.1 函数签名

```python
def spinning_cursor():
    """Generator for spinning cursor animation"""
    while True:
        for cursor in '|/-\\':
            yield cursor
```

spinning_cursor 是一个生成器函数，用于产生旋转指针动画效果。函数设计极其简洁，仅用 4 行代码实现了完整的功能。

### 5.2 设计原理

函数利用 Python 生成器的惰性求值特性，每次调用 next()（或迭代时的隐式调用）时产生下一个动画字符。内部是一个无限循环，循环遍历四个字符 '|/-\\'，形成顺时针旋转的视觉效果。

动画字符的选择基于以下考量：

- '|'：垂直竖线，代表指针12点钟方向
- '/'：斜杠，代表指针2点钟方向
- '-'：水平横线，代表指针3点钟方向
- '\\'：反斜杠，代表指针10点钟方向

四个字符依次显示，形成顺时针旋转的错觉。这种动画效果广泛应用于各种命令行工具中，用户普遍熟悉其含义（表示程序正在运行）。

### 5.3 使用方式

主函数中使用生成器的方式如下：

```python
spinner = spinning_cursor()
# ... 在检测过程中 ...
print(next(spinner), end="", flush=True)
```

创建生成器实例后，在检测循环的每次迭代中调用 next() 获取下一个字符并打印。end="" 参数防止自动换行，flush=True 确保字符立即显示（不缓冲）。

## 6. 数据结构详细说明

### 6.1 检测目标定义

```python
TARGETS = [
    ("homepage", "https://github.com"),
    ("api", "https://api.github.com"),
]
```

TARGETS 是列表（list）类型，包含两个元组（tuple）元素。每个元组有两个字符串字段：名称（name）和 URL。

| 字段 | 类型 | 说明                         |
| ---- | ---- | ---------------------------- |
| name | str  | 目标标识，用于显示和引用     |
| url  | str  | 完整 URL，用于发起 HTTP 请求 |

这种数据结构设计便于在检测时迭代使用，元组的不可变性确保配置不会被意外修改。

### 6.2 检测结果定义

\_single_result = {
"ok": bool, # 是否成功
"ms": int, # 延迟（毫秒）
"error": str # 可选，错误描述
}

单个检测结果使用字典（dict）类型存储。ok 字段是布尔类型，表示请求是否成功；ms 字段是整数，表示请求耗时；error 字段是可选的字符串，仅在请求发生异常时存在。

\_all_results = [
("homepage", _single_result),
("api", _single_result),
]

完整检测结果使用列表存储，每个元素是 (名称, 结果字典) 的元组。这种结构便于在展示时同时使用名称和结果数据。

### 6.3 返回结果定义

check 方法返回的完整结果定义为：

```python
{
    "status": str,       # 状态：good/warn/bad
    "ms": float,         # 总耗时（毫秒）
    "results": list,     # 检测结果列表
    "msg": str           # 状态消息
}
```

| 字段    | 类型  | 说明                 |
| ------- | ----- | -------------------- |
| status  | str   | 整体状态标识         |
| ms      | float | 从开始到结束的总耗时 |
| results | list  | 每个目标的检测结果   |
| msg     | str   | 用户友好的状态描述   |

这种结构设计便于主函数直接使用各字段进行展示和判断，无需额外的处理逻辑。

## 7. 算法设计说明

### 7.1 状态判断算法

状态判断是检测工具的核心算法，位于 \_judge 方法中。算法的设计目标是根据检测结果给出准确的状态判断，同时避免误判。

算法输入：检测结果列表，每个元素为 (名称, 结果字典) 形式。

算法输出：状态字符串（good/warn/bad）。

算法步骤：

**第一步：边界条件处理**

如果结果列表为空，返回 "bad"。这是防御性处理，避免后续逻辑出错。

**第二步：统计成功数量**

遍历结果列表，统计 ok 字段为 True 的数量。成功数量用于后续判断。

**第三步：状态判断**

- 如果成功数量为 0（全部失败），返回 "bad"
- 如果成功数量小于结果总数（部分失败），返回 "warn"
- 如果全部成功，计算平均延迟
  - 如果平均延迟 < 3000ms，返回 "good"
  - 否则返回 "warn"

算法的时间复杂度为 O(n)，其中 n 是检测目标数量（当前为 2）。空间复杂度为 O(1)，仅使用固定数量的变量。

### 7.2 超时控制算法

超时控制是保证检测效率的重要机制。check 方法实现了动态超时控制，确保即使在检测过程耗时较长时，剩余目标仍有合理的超时时间。

算法核心思想：每次检测开始时，根据已消耗的时间计算剩余可用时间，确保所有目标检测的总时间不超过设定的超时时间。

算法伪代码：

```
remaining_time = total_timeout - elapsed_time
if remaining_time < 1.0:
    remaining_time = 1.0
result = _test(url, remaining_time)
```

这种算法确保：

- 第一个目标有接近完整超时时间的机会
- 后续目标仍有合理的超时时间（至少1秒）
- 总时间不会显著超过设定的超时时间

### 7.3 加载动画算法

加载动画是一个简单的循环算法，通过不断打印不同字符产生视觉暂留效果。

算法伪代码：

```
cursors = ['|', '/', '-', '\\']
index = 0
while True:
    print(cursors[index], end="", flush=True)
    index = (index + 1) % len(cursors)
```

主函数在检测过程中周期性地调用 next() 获取下一个字符并打印，形成连续的动画效果。动画的刷新频率取决于检测循环的迭代速度，在本系统中约为每次 HTTP 请求后刷新一次。

## 8. 接口详细说明

### 8.1 命令行接口

#### 8.1.1 启动方式

工具可以通过两种方式启动：

**直接运行 Python 脚本**：

```bash
python cli.py
```

**通过启动脚本运行（Windows）**：

```bash
start.bat
```

start.bat 是为 Windows 用户提供的便捷启动方式，双击即可运行。脚本内容为：

```batch
@echo off
chcp 65001 >nul
python "%~dp0cli.py"
pause
```

脚本设置代码页为 UTF-65001，确保中文输出正确显示，然后执行 Python 脚本，最后 pause 命令保持窗口不立即关闭。

#### 8.1.2 命令行参数

当前版本暂不支持命令行参数，所有配置硬编码在代码中。这符合极简设计原则——90% 的使用场景不需要任何参数。

未来版本计划支持的参数包括：

- `-f, --full`：执行完整测试模式
- `-c, --count`：完整测试的检测次数
- `-i, --interval`：检测间隔秒数
- `-t, --timeout`：单次检测超时秒数
- `-v, --verbose`：显示详细输出

#### 8.1.3 退出码定义

| 退出码 | 含义                             |
| ------ | -------------------------------- |
| 0      | 程序正常结束（无论网络状态如何） |
| 1      | 发生错误或用户中断               |

退出码 0 的设计意味着：工具成功执行了检测任务并给出了结果，即使结果显示网络不可达，程序也是"成功"的。这种设计符合 Unix 传统，0 表示执行成功，非零表示执行过程中遇到了问题。

### 8.2 程序接口

Checker 类提供了简洁的对外接口，便于其他程序调用或测试。

#### 8.2.1 Checker.check()

```python
def check(self, timeout: float = 8.0) -> dict
```

执行单次检测，返回结果字典。

#### 8.2.2 使用示例

```python
from core.checker import Checker

# 创建检测器实例
chk = Checker()

# 执行检测
result = chk.check(timeout=8.0)

# 检查状态
if result["status"] == "good":
    print("可以推送代码")
elif result["status"] == "warn":
    print("网络不稳定，建议等待")
else:
    print("无法连接 GitHub")
```

这种接口设计使 Checker 类可以作为一个库被其他程序导入和使用，而不仅仅是一个命令行工具。

## 9. 代码规范与风格

### 9.1 命名规范

代码遵循 Python 社区的命名约定：

| 元素   | 规范             | 示例                   |
| ------ | ---------------- | ---------------------- |
| 类名   | PascalCase       | Checker                |
| 方法名 | snake_case       | check, \_test, \_judge |
| 函数名 | snake_case       | spinning_cursor        |
| 变量名 | snake_case       | results, timeout       |
| 常量名 | UPPER_SNAKE_CASE | 无（配置在类属性中）   |

私有方法使用单下划线前缀（\_method）标记，这是 Python 的约定，表示方法仅供内部使用。

### 9.2 注释规范

代码注释遵循以下原则：

**文件头注释**：使用文档字符串（docstring）描述模块功能。文档字符串使用三引号包裹，可以跨越多行。

**函数注释**：每个公共函数都应有文档字符串，说明功能、参数和返回值。私有方法（以 \_ 开头）也建议有简短的说明。

**行内注释**：在复杂或容易引起困惑的逻辑处添加注释。注释应当解释"为什么"而非"是什么"（代码本身应当清晰表达"是什么"）。

**示例**：

```python
def _test(self, url: str, timeout: float) -> dict:
    """Test single URL accessibility"""
    # ...
```

### 9.3 代码风格

代码遵循 PEP 8 Python 代码风格指南的主要规则：

**缩进**：使用4个空格缩进，不使用制表符。

**行宽**：每行不超过120字符（本项目代码行较短，未触及限制）。

**空行**：类定义之间空两行，方法定义之间空一行，逻辑段落之间空一行。

**空格**：运算符两侧加空格，逗号后加空格（但序列内部不加多余空格）。

**导入**：导入语句放在文件顶部，按标准库、第三方库、本地导入分组。

### 9.4 编码声明

文件顶部声明编码为 ASCII：

```python
# -*- coding: ascii -*-
```

这确保代码在任何环境下都能正确解析，不会因编码问题导致语法错误。代码中的所有字符串字面量都使用 ASCII 字符，包括注释和消息文本。

### 9.5 Python 版本兼容性

代码设计为兼容 Python 3.6+：

- 使用 f-string（Python 3.6+）
- 使用类型注解（Python 3.5+，但 3.6+ 广泛支持）
- 不使用 walrus operator（:=）等新特性

这种兼容性设计确保代码可以在大多数 Python 3 环境中运行。

## 10. 目录结构说明

### 10.1 项目根目录

项目根目录包含以下文件：

| 文件名     | 说明                         |
| ---------- | ---------------------------- |
| cli.py     | 主程序文件，包含所有功能实现 |
| start.bat  | Windows 启动脚本             |
| README.md  | 项目说明文档                 |
| LICENSE    | 开源许可证（MIT）            |
| .gitignore | Git 忽略配置                 |

### 10.2 docs 目录

docs 目录包含项目文档，采用中文编写：

| 文件名         | 说明         |
| -------------- | ------------ |
| 01-需求分析.md | 需求分析文档 |
| 02-系统设计.md | 系统设计文档 |
| 03-详细设计.md | 本文档       |

文档编号采用两位数字，便于排序和引用。文档使用 Markdown 格式，便于阅读和版本管理。

### 10.3 文件编码规范

| 目录/文件 | 编码  | 说明                          |
| --------- | ----- | ----------------------------- |
| \*.py     | ASCII | 代码文件使用 ASCII 编码       |
| \*.md     | UTF-8 | 文档使用 UTF-8 编码，支持中文 |
| \*.bat    | UTF-8 | 批处理文件使用 UTF-8 编码     |

这种编码安排确保代码在所有环境下都能正确运行，同时文档支持中文字符。

## 11. 未来扩展设计

### 11.1 完整测试模式

当前代码已实现完整测试模式,通过 test() 方法实现:

**test(timeout) 方法**：

```python
def test(self, timeout: float = 8.0) -> dict:
    """
    Perform full test with multiple checks and calculate average
    """
    results = []
    all_results = []

    print("Running full test (3 iterations)...")
    for i in range(3):
        print(f"  Iteration {i+1}/3...", end="\r")
        result = self.check(timeout=timeout)
        results.append(result)
        all_results.extend(result["results"])

    # Calculate overall statistics
    successful_checks = sum(1 for r in results if r["status"] != "bad")
    total_time = sum(r["ms"] for r in results)
    avg_time = total_time / len(results) if results else 0

    # Calculate average response times for each target
    target_stats = {}
    for name, url in self.TARGETS:
        target_results = [r for _, r in all_results if _ == name]
        if target_results:
            avg_response = sum(r.get("ms", 0) for r in target_results
                               if "ms" in r) / len(target_results)
            successful_responses = sum(1 for r in target_results
                                       if r.get("ok", False))
            target_stats[name] = {
                "avg_response": avg_response,
                "success_rate": successful_responses / len(target_results)
                                * 100
            }

    overall_status = self._judge(all_results)

    return {
        "status": overall_status,
        "msg": self._msg(overall_status, all_results),
        "iterations": 3,
        "avg_total_time": avg_time,
        "successful_checks": successful_checks,
        "target_stats": target_stats,
        "all_results": all_results
    }
```

test() 方法执行3次检测,计算整体统计信息和每个目标的平均响应时间及成功率。

### 11.2 配置文件扩展

未来可以引入配置文件支持，将硬编码的配置外置化：

```python
# config.json
{
    "targets": [
        {"name": "homepage", "url": "https://github.com"},
        {"name": "api", "url": "https://api.github.com"}
    ],
    "timeout": 8.0,
    "threshold": 3000
}
```

配置文件使用 JSON 格式，便于阅读和编辑。通过配置文件，用户可以自定义检测目标、超时时间和延迟阈值。

### 11.3 输出格式扩展

未来可以支持多种输出格式，如 JSON、CSV 等，便于与其他工具集成：

```python
def format_output(result: dict, format: str = "text") -> str:
    """Format output in specified format"""
    if format == "json":
        return json.dumps(result)
    elif format == "csv":
        # CSV formatting
    else:
        # Default text format
```

## 12. 测试设计说明

### 12.1 测试策略

系统采用手工测试为主、自动测试为辅的测试策略。考虑到项目规模和使用场景，手工测试能够覆盖大部分功能验证需求，同时保持代码的简洁性。

### 12.2 测试用例

**正常情况测试**：

| 用例              | 输入         | 预期输出                       |
| ----------------- | ------------ | ------------------------------ |
| GitHub 可达       | 网络正常     | status="good", msg 包含 "[OK]" |
| GitHub 部分不可达 | 部分目标失败 | status="warn"                  |
| GitHub 完全不可达 | 所有目标失败 | status="bad"                   |

**边界情况测试**：

| 用例       | 输入        | 预期输出               |
| ---------- | ----------- | ---------------------- |
| 超时       | timeout=0.1 | 快速失败，不阻塞       |
| 空 TARGETS | TARGETS=[]  | status="bad"           |
| 用户中断   | Ctrl+C      | 打印中断消息，退出码 1 |

### 12.3 测试方法

**手工测试步骤**：

1. 确保网络连接到 GitHub
2. 运行 python cli.py
3. 观察输出是否符合预期
4. 尝试 Ctrl+C 中断
5. 验证退出码

**自动化测试示例**：

```python
import unittest
from core.checker import Checker

class TestChecker(unittest.TestCase):
    def test_check_returns_dict(self):
        chk = Checker()
        result = chk.check(timeout=1.0)
        self.assertIsInstance(result, dict)
        self.assertIn("status", result)
        self.assertIn("results", result)

    def test_check_status_values(self):
        chk = Checker()
        result = chk.check(timeout=1.0)
        self.assertIn(result["status"], ["good", "warn", "bad"])
```

## 13. 实施指南

### 13.1 开发环境搭建

**步骤一：安装 Python**

确保已安装 Python 3.6 或更高版本。可通过以下命令验证：

```bash
python --version
```

**步骤二：安装依赖**

安装 requests 库：

```bash
pip install requests
```

**步骤三：获取代码**

克隆或下载项目代码到本地目录。

### 13.2 运行程序

**快速测试模式**：

```bash
python cli.py
```

或通过启动脚本（Windows）：

```bash
start.bat
```

### 13.3 开发建议

**代码修改**：代码文件 cli.py 包含所有功能，修改后保存即可生效，无需重新编译。

**调试技巧**：在代码中添加 print 语句可以方便地调试。requests.get() 调用支持 timeout 参数，可以用来测试超时行为。

**性能分析**：可以使用 time 模块测量代码各部分的执行时间，识别性能瓶颈。

## 14. 自动化工作流程检查脚本设计

### 14.1 模块概述

自动化工作流程检查脚本 `check_dev_workflow.py` 是项目开发过程中的质量保证工具，用于在代码提交前自动检查开发工作流程的合规性。该脚本通过执行6项核心检查，确保代码质量、测试覆盖率和文档完整性，帮助开发团队维持高标准的代码质量。

脚本的设计理念是"预防优于治疗"——在代码提交前发现问题，而不是在代码审查或生产环境中发现问题。这种前置检查机制显著降低了代码缺陷流入后续环节的风险，提高了整体开发效率。

### 14.2 脚本结构设计

脚本采用模块化设计，每个检查项独立实现为函数，便于维护和扩展。整体结构如下：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
自动化工作流程检查脚本
在代码提交前检查开发工作流程的合规性
"""

import subprocess
import sys
from pathlib import Path

# 检查函数
def check_code_style():
    """检查代码规范（Flake8）"""
    pass

def check_unit_tests():
    """检查单元测试（pytest）"""
    pass

def check_documentation():
    """检查文档完整性"""
    pass

def check_git_status():
    """检查Git状态"""
    pass

def check_readme():
    """检查README更新"""
    pass

def check_changelog():
    """检查CHANGELOG更新"""
    pass

# 主函数
def main():
    """执行所有检查"""
    pass

if __name__ == "__main__":
    sys.exit(main())
```

这种结构清晰明了，每个检查函数职责单一，主函数负责协调执行和结果汇总。

### 14.3 检查函数详细设计

#### 14.3.1 代码规范检查函数

**函数签名**：

```python
def check_code_style() -> bool
```

**功能说明**：
运行 Flake8 静态代码分析工具，检查 Python 代码是否符合 PEP 8 编码规范。

**实现逻辑**：

1. 使用 `subprocess.run()` 执行 `flake8` 命令
2. 检查返回码：0 表示通过，非0 表示存在代码规范问题
3. 如果检查失败，捕获并显示 Flake8 的错误输出
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_code_style():
    """检查代码规范（Flake8）"""
    print("检查代码规范...")
    result = subprocess.run(
        ["flake8", "."],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print("❌ 代码规范检查失败")
        print(result.stdout)
        return False
    print("✅ 代码规范检查通过")
    return True
```

**输出示例**：

```
检查代码规范...
✅ 代码规范检查通过
```

或失败时：

```
检查代码规范...
❌ 代码规范检查失败
./cli.py:50:1: E302 expected 2 blank lines, found 1
./cli.py:100:80: E501 line too long (82 > 79 characters)
```

#### 14.3.2 单元测试检查函数

**函数签名**：

```python
def check_unit_tests() -> bool
```

**功能说明**：
运行 pytest 测试框架，确保所有单元测试通过。

**实现逻辑**：

1. 使用 `subprocess.run()` 执行 `pytest` 命令
2. 检查返回码：0 表示所有测试通过，非0 表示有测试失败
3. 如果测试失败，捕获并显示 pytest 的输出
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_unit_tests():
    """检查单元测试（pytest）"""
    print("检查单元测试...")
    result = subprocess.run(
        ["pytest", "-v"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print("❌ 单元测试检查失败")
        print(result.stdout)
        return False
    print("✅ 单元测试检查通过")
    return True
```

**输出示例**：

```
检查单元测试...
✅ 单元测试检查通过
```

或失败时：

```
检查单元测试...
❌ 单元测试检查失败
test_judge.py::test_judge_all_fail FAILED
test_judge.py::test_judge_partial_fail FAILED
```

#### 14.3.3 文档完整性检查函数

**函数签名**：

```python
def check_documentation() -> bool
```

**功能说明**：
验证所有 Python 文件包含文档字符串（docstring），确保代码有适当的文档说明。

**实现逻辑**：

1. 遍历项目目录，查找所有 .py 文件
2. 对每个文件，检查是否包含 docstring
3. 如果发现缺少 docstring 的文件，记录并报告
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_documentation():
    """检查文档完整性"""
    print("检查文档完整性...")
    missing_docs = []

    for py_file in Path(".").rglob("*.py"):
        # 跳过 __pycache__ 目录
        if "__pycache__" in str(py_file):
            continue

        with open(py_file, 'r', encoding='utf-8') as f:
            content = f.read()
            if not content.strip().startswith('"""') and not content.strip().startswith("'''"):
                missing_docs.append(str(py_file))

    if missing_docs:
        print("❌ 文档完整性检查失败")
        print("以下文件缺少文档字符串：")
        for file in missing_docs:
            print(f"  - {file}")
        return False

    print("✅ 文档完整性检查通过")
    return True
```

**输出示例**：

```
检查文档完整性...
✅ 文档完整性检查通过
```

或失败时：

```
检查文档完整性...
❌ 文档完整性检查失败
以下文件缺少文档字符串：
  - ./utils.py
  - ./helpers.py
```

#### 14.3.4 Git状态检查函数

**函数签名**：

```python
def check_git_status() -> bool
```

**功能说明**：
确保 Git 工作区干净，无未提交的更改，避免遗漏文件提交。

**实现逻辑**：

1. 使用 `subprocess.run()` 执行 `git status --porcelain` 命令
2. 检查输出：空输出表示工作区干净，非空表示有未提交的更改
3. 如果有未提交的更改，显示更改文件列表
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_git_status():
    """检查Git状态"""
    print("检查Git状态...")
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        capture_output=True,
        text=True
    )

    if result.stdout.strip():
        print("❌ Git状态检查失败")
        print("工作区有未提交的更改：")
        print(result.stdout)
        return False

    print("✅ Git状态检查通过")
    return True
```

**输出示例**：

```
检查Git状态...
✅ Git状态检查通过
```

或失败时：

```
检查Git状态...
❌ Git状态检查失败
工作区有未提交的更改：
 M cli.py
?? new_file.py
```

#### 14.3.5 README更新检查函数

**函数签名**：

```python
def check_readme() -> bool
```

**功能说明**：
验证 README.md 文件已更新，确保文档与代码保持同步。

**实现逻辑**：

1. 使用 `subprocess.run()` 执行 `git diff HEAD -- README.md` 命令
2. 检查输出：非空输出表示 README.md 有更改
3. 如果 README.md 没有更改，提示用户更新
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_readme():
    """检查README更新"""
    print("检查README更新...")
    result = subprocess.run(
        ["git", "diff", "HEAD", "--", "README.md"],
        capture_output=True,
        text=True
    )

    if not result.stdout.strip():
        print("❌ README更新检查失败")
        print("README.md 文件未更新，请确保文档与代码保持同步")
        return False

    print("✅ README更新检查通过")
    return True
```

**输出示例**：

```
检查README更新...
✅ README更新检查通过
```

或失败时：

```
检查README更新...
❌ README更新检查失败
README.md 文件未更新，请确保文档与代码保持同步
```

#### 14.3.6 CHANGELOG更新检查函数

**函数签名**：

```python
def check_changelog() -> bool
```

**功能说明**：
验证 CHANGELOG.md 文件已更新，确保版本变更记录完整。

**实现逻辑**：

1. 使用 `subprocess.run()` 执行 `git diff HEAD -- CHANGELOG.md` 命令
2. 检查输出：非空输出表示 CHANGELOG.md 有更改
3. 如果 CHANGELOG.md 没有更改，提示用户更新
4. 返回布尔值表示检查是否通过

**关键代码**：

```python
def check_changelog():
    """检查CHANGELOG更新"""
    print("检查CHANGELOG更新...")
    result = subprocess.run(
        ["git", "diff", "HEAD", "--", "CHANGELOG.md"],
        capture_output=True,
        text=True
    )

    if not result.stdout.strip():
        print("❌ CHANGELOG更新检查失败")
        print("CHANGELOG.md 文件未更新，请记录版本变更")
        return False

    print("✅ CHANGELOG更新检查通过")
    return True
```

**输出示例**：

```
检查CHANGELOG更新...
✅ CHANGELOG更新检查通过
```

或失败时：

```
检查CHANGELOG更新...
❌ CHANGELOG更新检查失败
CHANGELOG.md 文件未更新，请记录版本变更
```

### 14.4 主函数设计

**函数签名**：

```python
def main() -> int
```

**功能说明**：
协调执行所有检查项，汇总结果并返回适当的退出码。

**实现逻辑**：

1. 定义检查项列表，按顺序执行
2. 逐个调用检查函数，记录结果
3. 如果任何检查失败，立即停止并返回退出码 1
4. 如果所有检查通过，打印成功消息并返回退出码 0

**关键代码**：

```python
def main():
    """执行所有检查"""
    print("=" * 50)
    print("自动化工作流程检查")
    print("=" * 50)
    print()

    checks = [
        ("代码规范检查", check_code_style),
        ("单元测试检查", check_unit_tests),
        ("文档完整性检查", check_documentation),
        ("Git状态检查", check_git_status),
        ("README更新检查", check_readme),
        ("CHANGELOG更新检查", check_changelog),
    ]

    all_passed = True
    for name, check_func in checks:
        if not check_func():
            all_passed = False
            break

    print()
    print("=" * 50)
    if all_passed:
        print("所有检查项通过！可以安全提交代码。")
        print("=" * 50)
        return 0
    else:
        print("部分检查项未通过，请修复后重试。")
        print("=" * 50)
        return 1
```

**输出示例（成功）**：

```
==================================================
自动化工作流程检查
==================================================

检查代码规范...
✅ 代码规范检查通过
检查单元测试...
✅ 单元测试检查通过
检查文档完整性...
✅ 文档完整性检查通过
检查Git状态...
✅ Git状态检查通过
检查README更新...
✅ README更新检查通过
检查CHANGELOG更新...
✅ CHANGELOG更新检查通过

==================================================
所有检查项通过！可以安全提交代码。
==================================================
```

**输出示例（失败）**：

```
==================================================
自动化工作流程检查
==================================================

检查代码规范...
❌ 代码规范检查失败
./cli.py:50:1: E302 expected 2 blank lines, found 1

==================================================
部分检查项未通过，请修复后重试。
==================================================
```

### 14.5 设计特点

#### 14.5.1 模块化设计

每个检查项独立实现为函数，职责单一，便于：

- **维护**：修改某个检查项不影响其他检查项
- **扩展**：添加新的检查项只需新增函数
- **测试**：可以单独测试每个检查函数

#### 14.5.2 友好输出

使用 ✅/❌ 符号清晰显示检查结果，用户可以快速识别通过/失败的检查项。输出信息包含：

- 检查项名称
- 检查结果（通过/失败）
- 失败时的详细错误信息

#### 14.5.3 详细反馈

失败时提供具体的错误信息和建议：

- 代码规范问题：显示 Flake8 的错误输出
- 测试失败：显示 pytest 的失败信息
- 缺少文档：列出缺少 docstring 的文件
- Git 状态：显示未提交的更改

#### 14.5.4 流程集成

脚本设计为在代码提交前执行，集成到开发工作流程中：

1. 开发人员完成代码修改
2. 运行 `python check_dev_workflow.py`
3. 根据检查结果修复问题
4. 所有检查通过后提交代码

### 14.6 使用方式

**执行命令**：

```bash
python check_dev_workflow.py
```

**集成到 Git Hook**（可选）：
可以在 `.git/hooks/pre-commit` 中添加以下内容，实现自动检查：

```bash
#!/bin/bash
python check_dev_workflow.py
if [ $? -ne 0 ]; then
    echo "工作流程检查失败，提交被中止"
    exit 1
fi
```

**实现状态**：✅ **已实现**

## 15. 文档修订记录

| 版本 | 日期       | 修订内容                             | 修订人 |
| ---- | ---------- | ------------------------------------ | ------ |
| 1.0  | 2024-12-23 | 初始详细设计文档                     | 项目组 |
| 1.1  | 2024-12-23 | 修正阈值判断逻辑说明（300ms→3000ms） | 项目组 |
| 1.2  | 2024-12-25 | 新增自动化工作流程检查脚本设计章节   | 项目组 |
